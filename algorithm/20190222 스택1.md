# 20190222 스택1



* 스택특성:

  * 물건쌓아올리듯

  * 스택에 저장된 자료는 선형구조 : 1:1로 연결되어 있다는 소리! 

    * 내가 방금 어떤 자료를 읽었으면 다음에 읽을 자료가 하나로 지정되어 있다.

      ex)리스트!

    * cf. 1:N의 관계는 하나를 읽고 그다음에 뭐 읽을지 N개 중에 결정해야 한다.

    * cf. 그래프는 N:N or 1:N

  * 추상자료형 : 자료형은 자료형인데 실체가 명확하지 않다.

  * C or C++로 구현가능. 

  * 동적이거나 정적인 메모리 구조로 다양하게 구현할 수 있다.

  * Last in First out = LIFO



### 스택의 구현

##### 스택을 구현하기 위해 필요한 자료구조와 연산

1. 자료구조: 자료를 선형으로 저장할 저장소
   - 마지막으로 삽입된 원소위치 = top
   - 리스트를 이용해 구현가능
   - 비어 있을 때 top=-1
2. 연산
   - 삽입
   - 삭제 : 빈 상태인지 체크해야 한다! 
   - isEmpty
   - peek : 탑에 있는 아이템이 뭔지 알려만 준다. 꺼내지 않는다.



##### 괄호연산

- 왼괄호 오괄호 개수가 같아야
- 같은 괄호의 왼괄호가 오괄호보다 먼저나와야 
- 괄호사이에는 포함관계만 존재

=> 반드시 여는 괄호의 역순대로 닫는 괄호가 나와야. 이런 경우에 스택을 사용한다.

=> 마지막 조건이 체크하기 까다롭다.



* 왼괄호 스택추가
* 오괄호 만나면 pop해서 짝맞나 확인
* 다돌리고 스택이 비어있어야 왼괄 호괄 개수맞는거





### Function call: 스택응용

함수호출의 순서를 관리한다. 

함수가 실행되는 데 필요한 정보들을 스택에 저장

top에는 지금 현재 실행중인 함수의 정보가 있다.

* 지역변수 매개변수, 복귀주소는 함수가 실행될 동안만 필요하고, 함수실행 이후에는 메모리에서 사라진다.
* 스택프레임 : 함수단위로 필요한 정보들을 저장한다.
* 함수호출되는 순서의 역으로 쌓이고, 종료후에는 사라진다.

메인 함수에서 기술된 함수, 그 함수의 내용, 그 함수의 내부에 기술된 함수,

-> F2가 돌아갈 곳은 F1



결국 함수를 호출한다는 것은 스택에 함수를 쌓는 것과 같다.

함수 혹은 재귀호출로 스택을 사용하는 효과를 얻을 수 있다.

역순으로 호출할 때 



* 파이썬 인터프레터는 C로 짜여져 있다.



##### Code 영역

- 함수마다 하나만 있으면 된다. 명령어 컴파일

##### Static Data 영역

* 전역변수: 프로그램 실행시 생성되어 종료 시까지 메모리에 살아있는 변수, 어떤 함수에서나 활용가능
* 상수 ex) 5=3 할당은 불가. 이런 것이 상수!
* 지역변수는 그때그때 메모리 할당되어 어디서나 활용이 불가하다.

##### Stack

* 함수가 실행될 때 필요한 지역변수 매개변수 등을 쌓아 놓는다.
* 메모리 공간에 컴파일된 프로그램이 올라가는 것을 프로세싱이라고한다. 함수호출이 이어지면 스택에 계속 함수정보가 쌓인다. stack overflow는 그런 뜻. 
* 컴퓨터 내부의 시스템 스택. 함수를 위한 메모리 공간이 스택 안에 할당. 그 안에 로컬 매개 변수 저장, 함수실행 끝난 후 사라진다.  -> 다른 곳에서 이 정보를 쓸 수 없다!!

##### Heap

* 동적 할당을 받아서 쓰는 공간.
* heap은 입력 등을 통해 새로운 데이터를 받을 때 실행 중에 메모리가 필요한 경우 사용하는 공간이다.
* 운영체제에게 그때그때 꾸어 쓴다고 생각하면 편함!
  - C나 C++은 운영체제에게 꾸어 메모리를 생성하는 함수가 있다. 
* 객체는 모두 힙에 생성된다.





코드와 스타틱 데이타, 스택까지는 실행(프로세싱) 이전에 이미 컴파일 단꼐에서 얼마나 용량이 필요한지를 계산할 수 있다.



### 재귀호출

* 함수가 자기 자신 호출해 순환수행한다.
* 일하는 내용은 같지만, 사용하는 데이터가 달라진다. 
* 부분적 문제를 하나하나 풀어서 전체 문제의 답을 얻을 때 사용
* 내가 풀려는 문제를 같은 유형의 작은 문제들로 나누기



##### 점화식

점화식의 형태로 분석해 내는 것이 재귀함수를 짜는 첫걸음!

점화식은 1 이상 자연수 n에 대해 정의

문제의 크기를 나타내는 값이 있다.  => 반드시 재귀함수의 매개변수로 주어져야만 한다!!!!!!!!

 - 내부의 로컬변수로는 판단할 수 없다. 그러면 포문짜면 된다.

   ex) n! factorial은 n의 크기를 가지는 문제다.

```python
def fact(n):
    if n <= 1:
        return 1
    return fact(n-1) * n

print(fact(5))
```



##### 기저사례

가장 base가 되는 케이스 : 이 경우에는 n==1

##### 유도된 사례

기저사례로부터 유도된 사례



매개변수를 보고 계속 부분으로 들어갈지, 끊을지를 판단해야 한다.

매개변수가 줄어들수록, 문제의 크기가 줄어든다는 것!



지역변수와 매개변수가 계속해서 반복되어 생성됨.

|n=1|

|n=2| -> n*2

|n=3| -> 3*2

|n=4| -> 6*4

return = 24



매개변수가 매번 함수호출시마다 새로 생기는 거다~~~~



##### DP: 재귀함수를 구현하고 점화식을 적용. 나중에 반복구조로 바꿈.

재귀호출 사용하는 알고리즘 예

- DFS: 깊이우선탐색 

- 분할정복
- 퀵정렬
- 트리 순회 : 전체트리는 큰 문제, 작은 트리는 작은 문제 
- 백트래킹 : 보통 DFS로 한다. 재귀호출을 쓴다. 
- 동적계획법(재귀적 DP라고 부름)



##### 재귀호출

- 일단 반복을 한다.



```python
for i in range(3):
   print('Hello World!')

def pr(n):
    if n == 0:
        return
    else:
        print('Hello World!')
        pr(n-1)

pr(3)
>> 3번 출력!
```

```python
cnt = 0
def printHello(i, n):
    global cnt
    if i == n:
        cnt += 1
        return
    printHello(i+1, n)
    printHello(i + 1, n)

printHello(0, 3)
print(cnt) # 2(함수 내 함수개수)의 n승
```

```python
cnt = 0
bit = [0]*3
def printHello(i, n):
    global cnt
    global bit
    if i == n:
        cnt += 1
        print(bit)
        return
    bit[i] = 1
    printHello(i+1, n)
    bit[i] = 0
    printHello(i + 1, n)


printHello(0, 3)
print(cnt) # 2(함수 내 함수개수)의 n승
```

##### Memoization

```python
memo = [0]*101

def fibo(n):
    if n<2: return n
    if memo[n] != 0:
        return memo[n]
    memo.append(fibo(n-2)+fibo(n-1))
    return fibo(n-2) + fibo(n-1)
```



### 동적계획법

중복계산을 줄이는 것!

이전에 계산한 값을 메모리에 더해서 전체 실행속도 증가

문제크기를 나타내는 n이 문제를 식별하는 값의 역할도 하도록 하는 것!

배열에 n번째 함수의 값을 저장하기!



* 백트래킹은 트리 형태로 답을 찾아서 탐색 기반 알고리즘

* 디피는 관계 기반(큰 문제와 작은 문제의 관계)으로 답을 찾는다. 

  * 작은 문제 답을 알고 있을 때 큰 문제의 답을 구하는 방법을 점화식으로 표현
  * 점화식을 찾으면 디피로 문제풀수있다.

  - 작은 문제가 먼저 풀려 있어야 다음 문제를 풀 수 있으므로 문제를 푸는 순서가 중요하다!!!!!
  - 문제 크기를 0부터 1씩 증가시키면서 풀면된다(피보나치)

* 디피 공부는 쉬운 문제를 마니 풀어봐라. 백준에서 경우의 수 구하기 이런거

* 점화식 찾는 연습!

```python
memo = [0]*101
memo[0]=0
memo[1]=1

for i in range(2, 41):
    if memo[i] == 0:
        memo[i] = memo[i-1] + memo[i-2]
else:
    print(memo[40])
```



### 그래프

실세계의 문제를 그래프로 추상화해서 해결하는 방법

* BFS DFS는 노드들 중 무엇을 먼저 읽을 것인지 선택하는 것!
* N:N 관계를 가지는 구조 표현하기에 용이!



##### 그래프의 종류 4가지

메모리에 나타내는 방법을 알아야!

* 무향 그래프 

  * 간선에 방향성이 없는 것(직선)

    ex) 친구 관계 그래프! 간선이 있으면 서로 친구로 생각함! 

* 유향 그래프

  * 간선에 방향이 하나씩 있는 것(화살표)

    ex) 짝사랑 그래프! 사랑의 짝대기

    ex) 대소관계로 화살표를 통해 그래프표현 가능!

* 가중치 그래프

  * 간선에 가중치가 있음

  



##### 인접(Adjacency)

* 둘 정점 사이에 간선이 있으면 인접해 있다고 한다.
* 완전그래프 : 임의의 두 정점들은 모두 인접해 있다.



##### 경로

간선을 순서대로 나열한 것.

* 단순경로: 경로 중 한 정점을  최대 한 번만 지나는 경로
* 사이클: 회로: 시작한 정점에서 끝나는 경로



##### 그래프 표현

* 그래프를 저장한다 = 간선을 저장한다~~~
  * 인접행렬: C
  * 인접리스트: Python



### DFS 깊이우선탐색

그래프!

<연습문제3> 197p.

그래프

```python
V, E = map(int, input().split()) #정점수, 간선수
G = [[] for _ in range(V+1)]
for i in range(E):
    u,v = map(int, input().split())
    G[u].append(v)
    G[v].append(u)#무향그래프라서 둘다!

for i in range(1, V+1):
    print(i, G[i])
```

> 1 [2, 3]
> 2 [1, 4, 5]
> 3 [1, 7]
> 4 [2, 6]
> 5 [2, 6]
> 6 [4, 5, 7]
> 7 [6, 3]

