# 20190222 스택1



* 스택특성:

  * 물건쌓아올리듯

  * 스택에 저장된 자료는 선형구조 : 1:1로 연결되어 있다는 소리! 

    * 내가 방금 어떤 자료를 읽었으면 다음에 읽을 자료가 하나로 지정되어 있다.

      ex)리스트!

    * cf. 1:N의 관계는 하나를 읽고 그다음에 뭐 읽을지 N개 중에 결정해야 한다.

    * cf. 그래프는 N:N or 1:N

  * 추상자료형 : 자료형은 자료형인데 실체가 명확하지 않다.

  * C or C++로 구현가능. 

  * 동적이거나 정적인 메모리 구조로 다양하게 구현할 수 있다.

  * Last in First out = LIFO



### 스택의 구현

##### 스택을 구현하기 위해 필요한 자료구조와 연산

1. 자료구조: 자료를 선형으로 저장할 저장소
   - 마지막으로 삽입된 원소위치 = top
   - 리스트를 이용해 구현가능
   - 비어 있을 때 top=-1
2. 연산
   - 삽입
   - 삭제 : 빈 상태인지 체크해야 한다! 
   - isEmpty
   - peek : 탑에 있는 아이템이 뭔지 알려만 준다. 꺼내지 않는다.



##### 괄호연산

- 왼괄호 오괄호 개수가 같아야
- 같은 괄호의 왼괄호가 오괄호보다 먼저나와야 
- 괄호사이에는 포함관계만 존재

=> 반드시 여는 괄호의 역순대로 닫는 괄호가 나와야. 이런 경우에 스택을 사용한다.

=> 마지막 조건이 체크하기 까다롭다.



* 왼괄호 스택추가
* 오괄호 만나면 pop해서 짝맞나 확인
* 다돌리고 스택이 비어있어야 왼괄 호괄 개수맞는거





### Function call: 스택응용

함수호출의 순서를 관리한다. 

함수가 실행되는 데 필요한 정보들을 스택에 저장

top에는 지금 현재 실행중인 함수의 정보가 있다.

* 지역변수 매개변수, 복귀주소는 함수가 실행될 동안만 필요하고, 함수실행 이후에는 메모리에서 사라진다.
* 스택프레임 : 함수단위로 필요한 정보들을 저장한다.
* 함수호출되는 순서의 역으로 쌓이고, 종료후에는 사라진다.

메인 함수에서 기술된 함수, 그 함수의 내용, 그 함수의 내부에 기술된 함수,

-> F2가 돌아갈 곳은 F1



결국 함수를 호출한다는 것은 스택에 함수를 쌓는 것과 같다.

함수 혹은 재귀호출로 스택을 사용하는 효과를 얻을 수 있다.

역순으로 호출할 때 



* 파이썬 인터프레터는 C로 짜여져 있다.



##### Code 영역

- 함수마다 하나만 있으면 된다. 명령어 컴파일

##### Static Data 영역

* 전역변수: 프로그램 실행시 생성되어 종료 시까지 메모리에 살아있는 변수, 어떤 함수에서나 활용가능
* 상수 ex) 5=3 할당은 불가. 이런 것이 상수!
* 지역변수는 그때그때 메모리 할당되어 어디서나 활용이 불가하다.

##### Stack

* 함수가 실행될 때 필요한 지역변수 매개변수 등을 쌓아 놓는다.
* 메모리 공간에 컴파일된 프로그램이 올라가는 것을 프로세싱이라고한다. 함수호출이 이어지면 스택에 계속 함수정보가 쌓인다. stack overflow는 그런 뜻. 
* 컴퓨터 내부의 시스템 스택. 함수를 위한 메모리 공간이 스택 안에 할당. 그 안에 로컬 매개 변수 저장, 함수실행 끝난 후 사라진다.  -> 다른 곳에서 이 정보를 쓸 수 없다!!

##### Heap

* 동적 할당을 받아서 쓰는 공간.
* heap은 입력 등을 통해 새로운 데이터를 받을 때 실행 중에 메모리가 필요한 경우 사용하는 공간이다.
* 운영체제에게 그때그때 꾸어 쓴다고 생각하면 편함!
  - C나 C++은 운영체제에게 꾸어 메모리를 생성하는 함수가 있다. 
* 객체는 모두 힙에 생성된다.





코드와 스타틱 데이타, 스택까지는 실행(프로세싱) 이전에 이미 컴파일 단꼐에서 얼마나 용량이 필요한지를 계산할 수 있다.



### 재귀호출

* 함수가 자기 자신 호출해 순환수행한다.
* 일하는 내용은 같지만, 사용하는 데이터가 달라진다. 
* 부분적 문제를 하나하나 풀어서 전체 문제의 답을 얻을 때 사용
* 내가 풀려는 문제를 같은 유형의 작은 문제들로 나누기



##### 점화식

점화식의 형태로 분석해 내는 것이 재귀함수를 짜는 첫걸음!

점화식은 1 이상 자연수 n에 대해 정의

문제의 크기를 나타내는 값이 있다.  => 반드시 재귀함수의 매개변수로 주어져야만 한다!!!!!!!!

 - 내부의 로컬변수로는 판단할 수 없다. 그러면 포문짜면 된다.

   ex) n! factorial은 n의 크기를 가지는 문제다.

```python
def fact(n):
    if n <= 1:
        return 1
    return fact(n-1) * n

print(fact(5))
```



##### 기저사례

가장 base가 되는 케이스 : 이 경우에는 n==1

##### 유도된 사례

기저사례로부터 유도된 사례



매개변수를 보고 계속 부분으로 들어갈지, 끊을지를 판단해야 한다.

매개변수가 줄어들수록, 문제의 크기가 줄어든다는 것!



지역변수와 매개변수가 계속해서 반복되어 생성됨.

|n=1|

|n=2| -> n*2

|n=3| -> 3*2

|n=4| -> 6*4

return = 24



매개변수가 매번 함수호출시마다 새로 생기는 거다~~~~



##### DP: 재귀함수를 구현하고 점화식을 적용. 나중에 반복구조로 바꿈.

재귀호출 사용하는 알고리즘 예

- DFS: 깊이우선탐색 

- 분할정복
- 퀵정렬
- 트리 순회 : 전체트리는 큰 문제, 작은 트리는 작은 문제 
- 백트래킹 : 보통 DFS로 한다. 재귀호출을 쓴다. 
- 동적계획법(재귀적 DP라고 부름)
- 

